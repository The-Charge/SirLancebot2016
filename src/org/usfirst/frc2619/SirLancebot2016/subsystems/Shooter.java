// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2619.SirLancebot2016.subsystems;

import org.usfirst.frc2619.TheChargeDashboard;
import org.usfirst.frc2619.SirLancebot2016.Robot;
import org.usfirst.frc2619.SirLancebot2016.RobotMap;
import org.usfirst.frc2619.SirLancebot2016.commands.*;

import edu.wpi.first.wpilibj.CANTalon;

import edu.wpi.first.wpilibj.CANTalon.TalonControlMode;

import edu.wpi.first.wpilibj.DoubleSolenoid;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class Shooter extends Subsystem {

	private final static double SPEED_P_CONSTANT = .05;
    private final static double SPEED_I_CONSTANT = 0 ;
    private final static double SPEED_D_CONSTANT = 0;
    private final static double SPEED_F_CONSTANT = .033;
    private final static int MAX_TICKS_PER_SECOND = 34000; //TODO: possibly edit this value (see left) to create a constant suited for the shooter's max velocity
    private final static double DEFAULT_INTAKE_PERCENTSPEED = .1;
    public double speed = 0;
    private int chkShooterEncSpeed;
    private int chkIntakeEncSpeed;
    private final static double DEFAULT_BUTTON_BOX_SHOOTER_SPEED = 0.8;
    
    double SpeedP = SPEED_P_CONSTANT;
    double SpeedI = SPEED_I_CONSTANT;
    double SpeedD = SPEED_D_CONSTANT;
    double SpeedF = SPEED_F_CONSTANT;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon leftShooterMotor = RobotMap.shooterleftShooterMotor;
    private final CANTalon rightShooterMotor = RobotMap.shooterrightShooterMotor;
    private final DoubleSolenoid shooterLift = RobotMap.shootershooterLift;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public Shooter()
    {
    	chkShooterEncSpeed = 0;
    	writeDefaultDashboardValues();
    	initSpeedMode();
    }

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    private void writeDefaultDashboardValues() {
    	TheChargeDashboard.putNumber("ShooterSpeedP", SPEED_P_CONSTANT);
    	TheChargeDashboard.putNumber("ShooterSpeedI", SPEED_I_CONSTANT);
    	TheChargeDashboard.putNumber("ShooterSpeedD", SPEED_D_CONSTANT);
    	TheChargeDashboard.putNumber("ShooterSpeedF", SPEED_F_CONSTANT);
    	TheChargeDashboard.putNumber("ShooterSpeedFromPot", speed);
    	
    	//Speed for the intake system
    	TheChargeDashboard.putNumber("IntakePercentSpeed<DEBUG>", DEFAULT_INTAKE_PERCENTSPEED);
    }
    
    public void readDashboardControlValues()
    {
    	SpeedP = SmartDashboard.getNumber("ShooterSpeedP", SPEED_P_CONSTANT);
    	SpeedI = SmartDashboard.getNumber("ShooterSpeedI", SPEED_I_CONSTANT);
    	SpeedD = SmartDashboard.getNumber("ShooterSpeedD", SPEED_D_CONSTANT);
    	SpeedF = SmartDashboard.getNumber("ShooterSpeedF", SPEED_F_CONSTANT);
    	
    	//set CANTalon PIDs
    	leftShooterMotor.setPID(SpeedP, SpeedI,SpeedD, SpeedF, 0, 0, 0);
    	rightShooterMotor.setPID(SpeedP, SpeedI, SpeedD, SpeedF, 0, 0, 0);	
    }
    
    public void writeDashboardDebugValues()
	{
		//Output Speed of Encoders
		TheChargeDashboard.putNumber("ShooterLeftSpeed",leftShooterMotor.getEncVelocity());
		TheChargeDashboard.putNumber("ShooterRightSpeed",rightShooterMotor.getEncVelocity());
		
		//Output verification for the Encoder Speed within the subsystem
		TheChargeDashboard.putNumber("ShooterSpeedCheck<DEBUG>", chkShooterEncSpeed);
		TheChargeDashboard.putNumber("IntakeSpeedCheck<DEBUG>", chkIntakeEncSpeed);
		TheChargeDashboard.putNumber("ShooterSpeedFromPot", chkShooterEncSpeed);
	}
    
    public void initSpeedMode()
    {
    	leftShooterMotor.setControlMode(CANTalon.TalonControlMode.Speed.getValue());
    	rightShooterMotor.setControlMode(CANTalon.TalonControlMode.Speed.getValue());
    }
    /**
     * 
     * @param speed double percent of speed to run at a velocity (Percentage of Speed used)
     */
    public void prepShooter(double speed)
    {
    	chkShooterEncSpeed = (int)speed * MAX_TICKS_PER_SECOND;
    	leftShooterMotor.set(chkShooterEncSpeed);
    	rightShooterMotor.set(chkShooterEncSpeed);    	
    }
    
    public double convertDistanceToSpeed(double distance)
    {
    	//TODO: convert the distance from the camera to a speed for the shooters
    	return 0;
    }
    
    /**
     * 
     * @param speed double percent of speed to run at a velocity (Percentage of Speed used)
     */
    public void intake(double speed)  //needed to get speed from somewhere else???
    {
    	prepShooter(-speed);
	}
    
    public void intake()
    {
    	intake(0.1);
    }
    
    
    public void liftShooter()
    {
    	shooterLift.set(DoubleSolenoid.Value.kForward);
    }
    
    public void lowerShooter()
    {
    	shooterLift.set(DoubleSolenoid.Value.kReverse);
    }
    
    public void stop()
    {
    	leftShooterMotor.set(0);
    	rightShooterMotor.set(0);
    }
    
}

